## Оглавление
#### **Проект работает на версии Python 3.8.x - 3.10.x. На версиях выше или ниже работоспособность не гарантируется.**
- [maintemplate](#maintemplate)
  - [systemd](#systemd)
    - [tgbot.service](#tgbot.service)
  - [tgbot](#tgbot)
    - _[filters](#filters)_
      - [admin.py](#admin.py)
      - [button_filter.py](#button_filter.py)
      - [logger.py](#logger.py) 
      - [settings_button.py](#settings_button.py)
    - _[handlers](#handlers)_
        - [admin.py](#admin.py)
        - [echo.py](#echo.py)
        - [user.py](#user.py)
    - _[keyboard](#keyboard)_
      - [inline.py](#inline.py)
      - [reply.py](#reply.py)
    - _[middleware](#middleware)_
      - [db.py](#db.py)
      - [throttling.py](#throttling.py)
    - _[misc](#misc)_
      - [set_bot_commands.py](#tgbot)
      - [state.py](#state.py)
    - _[models](#models)_
      - [database.db](#database.db)
      - [users.py](#users.py)
    - _[services](#services)_
    - [config.py](#config.py)
  - [env.dist](#env.dist)
  - [gitignore](#gitignore)
  - [bot.py](#bot.py)
  - [README.md](#README.md)
  - [requirements.txt](#requirements.txt)

## maintemplate

____
Вся структура бота находится в основной папке, папку можно называть как угодно, главное чтобы она была названа на
английском языке с использованием маленьких букв.
Внутри проекта хранятся следующие необходимые для работы папки и файлы.
В каждой подпапке tgbot хранятся `__init__.py` файлы, они нужны для определения каталога, как каталога python директории.
Проект написан без использования глобальных переменных, если они присутствуют, пожалуйста сообщите мне, спасибо.

____
[:arrow_up:Оглавление](#Оглавление)
____

## systemd

Systemd - система инициализации которая управляет службами в операционной системе Linux. 
На данный момент Systemd присутствует в таких дистрибутивах как Debian, Ubuntu, Linux Mint, Manjaro и во многих других.
С помощью Systemd можно создавать свои так называемые Unit (Юнит), тем самым автоматизировав необходимый процесс. 
Сам же юнит можно назвать скриптом, выполняющим определенные действия, если конечно прописать в него эти действия.
Источник и примеры: [Ссылка](https://cyber-x.ru/%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%B5%D0%BC-systemd-%D1%8E%D0%BD%D0%B8%D1%82-unit-%D0%BD%D0%B0-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B5-telegram-%D0%B1%D0%BE%D1%82%D0%B0/)

____
[:arrow_up:Оглавление](#Оглавление)
____

## tgbot.service

Пример файла: 
```
[Unit]
Description=Company Bot         # Описание проекта
After=network.target            # Настройки конечной цели соединения

[Service]
User=tgbot                      # Пользователь
Group=tgbot                     # Группа
Type=simple                     # Тип
WorkingDirectory=/opt/tgbot     # Рабочая директория
ExecStart=/opt/tgbot/venv/bin/python bot.py # Стартовый файл
Restart=always                  # Режим рестарта

[Install]
WantedBy=multi-user.target      # Режим использования (мульти-режим)
```
Источник: [Ссылка Habr](https://habr.com/ru/company/southbridge/blog/255845/)

____
[:arrow_up:Оглавление](#Оглавление)
____

## tgbot

Основная папка содержащая в себе большую часть настроек для работы с ботом.
В ней хранятся подпапки для лучшего понимания функций и задач каждого файла.

____
[:arrow_up:Оглавление](#Оглавление)
____

## filters

Папка фильтры содержит в себе фильтрацию информации по заданным пользователем алгоритмам.
В данной папке прописаны фильтры для:
1. Отлавливания сообщений только для админа;
2. Отлавливания нажатий на кнопки;
3. Логгирование для дебага кода и удобства вывода ошибок;
4. Настройка кнопок для удобного прописывания клавиатуры внутри бота.

____
[:arrow_up:Оглавление](#Оглавление)
____

## admin.py

```
import typing
from aiogram.dispatcher.filters import BoundFilter
from tgbot.config import Config

class AdminFilter(BoundFilter):             # Админ класс наследованный от BoundFilter
    key = 'is_admin'                        # Ключ по которому будем определять админа

    def __init__(self, is_admin: typing.Optional[bool] = None):
        self.is_admin = is_admin            # В данном случае is_admin является bool значением (True or False)

    async def check(self, obj):             # Проверка пользователя на админа
        if self.is_admin is None:
            return False                    # Если айди не совпал, возвращаем False
        config: Config = obj.bot.get('config')     # Берём из конфигурации айди админа
        return (obj.from_user.id in config.tg_bot.admin_ids) == self.is_admin  # Если он совпадает возвращается True
```
____
[:arrow_up:Оглавление](#Оглавление)
____

## button_filter.py

Данный фильтр используется для прописывания в register_inline_handler() нажатия на кнопку.
Выглядит это следующим образом, есть inline кнопка с `callback - test_inl`, нажатие на неё нужно отследить, 
код будет выглядеть так:

```
register_inline(dp: Dispatcher):
    dp.register_inline_handler(Button('test_inl')
```

____
[:arrow_up:Оглавление](#Оглавление)
____

## logger.py

Логгирование прописано с использованием библиотеки `loguru` и встроенной python библиотеки `logging`.
Оно запускается в главном файле bot.py с помощью функции `await setup_logger()`.
Библиотека loguru облегчает отлов ошибок и просмотр информации о работе кода.


____
[:arrow_up:Оглавление](#Оглавление)
____

## settings_button.py

Настройка клавиатуры нужна для простого создания больших клавиатур, за место старого способа прописывания клавиатуры,
будет лучше использовать `class ListOfButtons`, который имеет параметры `text` - текст кнопки, 
`callback` - для инлайн кнопок способ отловить нажатие и `align` - количество кнопок в строке.

____
[:arrow_up:Оглавление](#Оглавление)
____

## handlers

Папка содержащая основные функции для отлова сообщений. При отправке сообщения бот получает информацию от пользователя
и чтобы решить что с ней делать, нужно сообщение обработать, а за это как раз отвечает handler (обработчик).
В данной папке необходимо хранить только обработчики сообщений, будь то текстовые сообщения или нажатие на кнопки.

____
[:arrow_up:Оглавление](#Оглавление)
____

## admin.py

```
from aiogram import Dispatcher
from aiogram.types import Message

async def admin_start(message: Message):        # Если фильтрация на админа прошла успешно
    await message.reply("Hello, admin!")        # Бот отправит сообщение только админу

# Регистрация хендлеров передаётся в главный стартовый файл bot.py
def register_admin(dp: Dispatcher):             # В если админ=True, тогда сообщение попадёт по адрессу
    dp.register_message_handler(admin_start, commands=["start"], state="*", is_admin=True)
```
____
[:arrow_up:Оглавление](#Оглавление)
____

## echo.py

Эхо хендлер принимает сообщения любого типа и отвечает на них заданным пользователем алгоритмом, только в случае если
данное сообщение не попало в другие хендлеры и не прошло особую фильтрацию. Для корректной работы эхо хендлера,
в основном файле bot.py функцию регистрации эхо хендлера нужно прописать ниже основных функций хендлеров.

____
[:arrow_up:Оглавление](#Оглавление)
____

## user.py

Данный файл прописан для примерного понимания прописывания функций и их регистрации в hendler'ах. 
Файл содержит примеры: 
1. Сброс машино-состояния `await state.reset_state(with_data=True)`; 
2. Отправки простого текстового сообщения, на сообщение пользователя по команде - `/start` с клавиатурой;
3. Фиксирования пользователя в состоянии ответа на второе сообщение, то есть следующее сообщение 100% попадает
в следующий заданный хендлер;
4. Следующий хендлер отвечает на второе сообщение пользователя, фиксация состояния пользователя прописывается в
строчке регистрации `dp.register_message_handler(user_two, state=Test.first_state)`;
5. Далее прописан метод удаления клавиатуры для пользователя;
6. Строчкой ниже отправка ответа с удалённой клавиатурой, за удаление отвечает фрагмент `reply_markup=reply_markup`;
7. `await state.finish()` выводит пользователя из машино-состояния;
8. Последний хендлер принимает сообщение содержащее изображения, это регулируется типом сообщения которое ждёт функция,
в регистрации хендлера прописывается тип - `content_types=types.ContentTypes.PHOTO`.

Финальный вид регистрации выглядит так:
```
def register_user(dp: Dispatcher):
    dp.register_message_handler(user_start, commands=["start"])
    dp.register_message_handler(user_two, state=Test.first_state)
    dp.register_message_handler(user_photo, content_types=types.ContentTypes.PHOTO)
```
____
[:arrow_up:Оглавление](#Оглавление)
____

## keyboard









____
[:arrow_up:Структура проекта](#Структура проекта)
___
## Заголовки

Всего существует шесть уровней заголовков. Для того, чтобы создать заголовок, необходимо в начале строки добавить символы `#`, в количестве равном его уровню.
____
# Заголовок первого уровня
```
# Заголовок 1
```
Заголовок первого уровня также можно создать:
```
Заголовок 1
===========
```
____
## Заголовок второго уровня
```
## Заголовок 2
```
Заголовок второго уровня также можно создать:
```
Заголовок 2
-----------
```
____
### Заголовок третьего уровня
```
### Заголовок 3
```
____
#### Заголовок четвертого уровня
```
#### Заголовок 4
```
____
##### Заголовок пятого уровня
```
##### Заголовок 5
```
____
###### Заголовок шестого уровня
```
###### Заголовок 6
```
____
[:arrow_up:Оглавление](#Оглавление)
____
## Работа с выделением текста

```
~~Зачеркнутый текст~~
```
~~Зачеркнутый текст (Strikethrough)~~

Для выделения текста **`жирным`** или *`наклонным`* и их сочетания можно использовать комбинации `*` или `_`

```
**Жирный текст (bold)**
```
**Жирный текст (bold)**

```
*Наклонный текст (italic)*
```
*Наклонный текст (italic)*

```
***Жирный наклонный текст (bold italic)***
```
***Жирный наклонный текст (bold italic)***

```
__Жирный текст (bold)__
```
__Жирный текст (bold)__

```
_Наклонный текст (italic)_
```
_Наклонный текст (italic)_

```
___Жирный наклонный текст (bold italic)___
```
___Жирный наклонный текст (bold italic)___

```
~~*__Тут странный текст__*~~
```
~~*__Тут странный текст__*~~
    
[:arrow_up:Оглавление](#Оглавление)
____
## Использование эмодзи (emoji)
В самом тексте можно использовать эмодзи, например написать вот так:    
:white_check_mark: Это уже сделано    
:negative_squared_cross_mark: Я не буду это делать    
:black_square_button: делать или не делать, вот в чем вопрос?    
В оригинале это выглядит так (в конце строки четыре (4) пробела для того, что бы был переход на новую строку):
```
:white_check_mark: Это уже сделано    
:negative_squared_cross_mark: Я не буду это делать    
:black_square_button: делать или не делать, вот в чем вопрос?    
```

Список работающих Эмодзи находится тут -> [emoji.md](https://github.com/GnuriaN/format-README.md/blob/master/emoji.md)    
    
[:arrow_up:Оглавление](#Оглавление)
___
## Использование цитирования в тексте
```
> Цитата (уровень 1)    
> > Вложенная цитата (уровень 2)    
> > > Вложенная цитата (уровень 3)    

> > Продолжение цитаты (уровень 2)    

> Продолжение цитаты (уровень 1)    
```
> Цитата (уровень 1)    
> > Вложенная цитата (уровень 2)    
> > > Вложенная цитата (уровень 3)    

> > Продолжение цитаты (уровень 2)    

> Продолжение цитаты (уровень 1)    

Внешний вид, конечно, не очень, но может и пригодиться.

[:arrow_up:Оглавление](#Оглавление)
___
## Подсветка кода

Если нужно выделить слово или фразу внутри строки, то используются одинарные обратные кавычки (`):

    Это `слово` будет выделено

Для выделения в блоки - тройные:

    ```
        Здесь может быть
        Ваша реклама
    ```

Дополнительно можно задавать язык кода внутри блока, указав его после первых трех кавычек:

    ```html
        <input type="text">
    ```

    ```css
        body {
            margin: 0;
            padding: 0;
        }
    ```

    ```php
        <?php phpinfo();?>
    ```

Пример блока для `C#`:

```C#
using MarkdownSharp;
using MarkdownSharp.Extensions.Mal;

Markdown mark = new Markdown();

// Short link for MAL - 
// http://myanimelist.net/people/413/Kitamura_Eri => mal://Kitamura_Eri
mark.AddExtension(new Articles()); 
mark.AddExtension(new Profile());

mark.Transform(text);
```

Пример блока для `Python`:
```Python
from timeit import Timer

tmp = "Python 3.2.2 (default, Jun 12 2011, 15:08:59) [MSC v.1500 32 bit (Intel)] on win32."

def case1(): # А. инкрементальные конкатенации в цикле
    s = ""
    for i in range(10000):
        s += tmp

def case2(): # Б. через промежуточный список и метод join
    s = []
    for i in range(10000):
        s.append(tmp)
    s = "".join(s)

def case3(): # В. списковое выражение и метод join
    return "".join([tmp for i in range(10000)])

def case4(): # Г. генераторное выражение и метод join
    return "".join(tmp for i in range(10000))

for v in range(1,5):
    print (Timer("func()","from __main__ import case%s as func" % v).timeit(200))
```
    
[:arrow_up:Оглавление](#Оглавление)
___
## Списки

#### Маркированный
Задать **маркированный** список можно несколькими символами `-`, `+` или `*`:
```
- Уровень списка 1. Пункт 1.
- Уровень списка 1. Пункт 2.
- Уровень списка 1. Пункт 3.
```
- Уровень списка 1. Пункт 1.
- Уровень списка 1. Пункт 2.
- Уровень списка 1. Пункт 3.

```
+ Уровень списка 1. Пункт 1.
+ Уровень списка 1. Пункт 2.
+ Уровень списка 1. Пункт 3.
```
+ Уровень списка 1. Пункт 1.
+ Уровень списка 1. Пункт 2.
+ Уровень списка 1. Пункт 3.

```
* Уровень списка 1. Пункт 1.
* Уровень списка 1. Пункт 2.
* Уровень списка 1. Пункт 3.
```
* Уровень списка 1. Пункт 1.
* Уровень списка 1. Пункт 2.
* Уровень списка 1. Пункт 3.

Можно создавать многоуровневые списки. Каждый уровень отделяется **четырьмя** (4) пробелами:
```
- Уровень списка 1. Пункт 1.
    - Уровень списка 2. Пункт 1.
- Уровень списка 1. Пункт 2.
    - Уровень списка 2. Пункт 1.
    - Уровень списка 2. Пункт 2.
- Уровень списка 1. Пункт 3.
    - Уровень списка 2. Пункт 1.
        - Уровень списка 3. Пункт 1.
        - Уровень списка 3. Пункт 2.
           - Уровень списка 4. Пункт 1.
```

Каждый уровень отделяется двумя пробелами.

#### Нумерованный
Для Githib работа с нумерованными списками выглядит очень интересно. Каждый уровень отделяется **четырьмя** (4) пробелами:
```
1. Первый уровень 1
    1. Второй уровень 1
        1. Третий уровень 1
            1. Четвертый уровень 1
                1. Пятый уровень 1
                    1. Шестой уровень
                        1. Седьмой уровень
                            1. Седьмой уровень
2. Первый уровень 2
2. Первый уровень (должно быть 3)
4. Первый уровень 4
```
1. Первый уровень 1
    1. Второй уровень 1
        1. Третий уровень 1
            1. Четвертый уровень 1
                1. Пятый уровень 1
                    1. Шестой уровень
                        1. Седьмой уровень
                            1. Седьмой уровень
2. Первый уровень 2
2. Первый уровень (должно быть 3)
4. Первый уровень 4

#### Смешанные списки
При использовании смешанных списков нужно очень внимательно следить за нумерацией. Лучше, как и в нумерованных, использовать четыре (4) пробела для отделения уровня.
```
1. Первый уровень "нумерованный" - 1
    * Второй уровень "маркер"
        + Третий уровень "маркер"
        - Третий уровень "маркер"
        1. Третий уровень "нумерованный" - 1
            1. Четвертый уровень "нумерованный" - 1
                1. Пятый уровень "нумерованный" - 1
                    1. Шестой уровень "нумерованный" - 1
                        1. Седьмой уровень "нумерованный" - 1
                        * Седьмой уровень "маркер"
                        2. Седьмой уровень "нумерованный" - 1 (нарушена нумерация, новая нумерация 1)
                        3. Седьмой уровень "нумерованный" - 1 (нарушена нумерация, новая нумерация 2)
                            1. Восьмой уровень "нумерованный" - 1
2. Первый уровень "нумерованный" - 2
- Первый уровень "нумерованный" - 3
4. Первый уровень "нумерованный" - 4 (нарушена нумерация, новая нумерация 1)
5. Первый уровень "нумерованный" - 5 (нарушена нумерация, новая нумерация 2)
```
1. Первый уровень "нумерованный" - 1
    * Второй уровень "маркер"
        + Третий уровень "маркер"
        - Третий уровень "маркер"
        1. Третий уровень "нумерованный" - 1
            1. Четвертый уровень "нумерованный" - 1
                1. Пятый уровень "нумерованный" - 1
                    1. Шестой уровень "нумерованный" - 1
                        1. Седьмой уровень "нумерованный" - 1
                        * Седьмой уровень "маркер"
                        2. Седьмой уровень "нумерованный" - 2
                        3. Седьмой уровень "нумерованный" - 3
                            1. Восьмой уровень "нумерованный" - 1
2. Первый уровень "нумерованный" - 2
- Первый уровень "маркерный" - 3
4. Первый уровень "нумерованный" - 4 (хотя по идее должен быть 3)
5. Первый уровень "нумерованный" - 5 (хотя, по идее должен быть 3)

#### Список задач
(Task List)
Можно создавать "Списки задач" для этого необходимо использовать `- [ ]` для поставленной задачи и `- [X]` для выполненной задачи.
```
- [X] Придумать внешний вид резюме
- [ ] Написать основные категории
- [X] Опубликовать

```
- [X] Придумать внешний вид резюме
- [ ] Написать основные категории
- [X] Опубликовать

Также можно создавать многоуровневые списки задач. Каждый уровень отделяется **четырьмя** (4) пробелами:
```
- [X] Задача 1
    - [X] Подзадача 1 для Задачи 1
    - [X] Подзадача 2 для Задачи 1
- [ ] Задача 2
    - [X] Подзадача 1 для Задачи 2
    - [ ] Подзадача 2 для Задачи 2
- [ ] Задача 3
    - [ ] Подзадача 1 для Задачи 3
        - [ ] Подзадача 1 для Подзадача 1 для Задачи 3
```
- [X] Задача 1
    - [X] Подзадача 1 для Задачи 1
    - [X] Подзадача 2 для Задачи 1
- [ ] Задача 2
    - [X] Подзадача 1 для Задачи 2
    - [ ] Подзадача 2 для Задачи 2
- [ ] Задача 3
    - [ ] Подзадача 1 для Задачи 3
        - [ ] Подзадача 1 для Подзадача 1 для Задачи 3
    
[:arrow_up:Оглавление](#Оглавление) 
___
## Ссылки
Либо просто вставить ссылку, либо дополнительно задать текст ссылки (пробела между скобками быть не должно):
```
Первый вариант вставки ссылок - это просто написать адрес сайта http://sabaka.net
```
Первый вариант вставки ссылок - это просто написать адрес сайта http://sabaka.net

Второй вариант записывается так: `[текст ссылки](адрес ссылки)`
```
[sabaka.net](http://sabaka.net)
```
[sabaka.net](http://sabaka.net)
    
[Sabaka(DOT)Net]:http://sabaka.net    
    
[:arrow_up:Оглавление](#Оглавление)
____
## Вставка изображения
```
![Alt-текст](https://avatars1.githubusercontent.com/u/5384215?v=3&s=460 "Орк")
```
![Alt-текст](https://avatars1.githubusercontent.com/u/5384215?v=3&s=460 "Орк")

### Дополнительно:
#### Вставка ссылки с картинкой на ролик с YouTube
Описание комбинации `[![Тут текст](адрес до картинки)](ссылка на страничку YouTube)`        
Пример:        
```[![Тут текст](https://img.youtube.com/vi/RHPYGwVQB2o/0.jpg)](https://youtu.be/RHPYGwVQB2o)```        
Что мы увидим:        
[![Тут текст](https://img.youtube.com/vi/RHPYGwVQB2o/0.jpg)](https://youtu.be/RHPYGwVQB2o)        
        
[:arrow_up:Оглавление](#Оглавление) 
____
## Вставка таблиц
```
| LEFT | CENTER | RIGHT |
|----------------|:---------:|----------------:|
| По левому краю | По центру | По правому краю |
| текст | текст | текст |
```
| LEFT | CENTER | RIGHT |
|----------------|:---------:|----------------:|
| По левому краю | По центру | По правому краю |
| текст | текст | текст |

**Внимание:** Если в тексте таблицы нужно использовать символ "вертикальная черта - `|`", то в место него необходимо написать замену на комбинацию HTML-кода* `&#124;`, это нужно для того, что бы таблица не потеряла ориентации.    
*) - Можно использовать ASCII и/или UTF коды.

**Пример:**
```
| Обозначение | Описание | Пример регулярного выражения|
|----:|:----:|:----------|
| literal | Строка содержит символьный литерал literal | foo |
| re1&#124;re2 | Строка содержит регулярные выражения `rel` или `re2` | foo&#124;bar |
```
**Результат:**

| Обозначение | Описание | Пример регулярного выражения|
|----:|:----:|:----------|
| literal | Строка содержит символьный литерал literal | foo |
| re1&#124;re2 | Строка содержит регулярные выражения `rel` или `re2` | foo&#124;bar |

[:arrow_up:Оглавление](#Оглавление) 
____
